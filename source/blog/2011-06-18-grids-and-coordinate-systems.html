---
layout: post
title: Grids & Coordinate Systems
date: 2011-06-18T08:50:01+00:00
---
<p>
For a software project (a multi-user browser game) I am currently
evaluating different sorts of grid and coordinate system combinations. I
came across a few great posts about that topic (<a
  href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/">Amit’s Thoughts on Grids</a>
and
<a href="http://simblob.blogspot.com/2007/06/distances-on-triangular-grid.html">Blobs in Games: Distances on a triangular grid</a>).
The latter provides a promising coordinate system based on
<a href="http://cit.zesoi.fer.hr/downloadPaper.php?paper=435">this paper</a>.
To review the grid and coordinate system I put together an example.
</p>

<h2>Example </h2>
<p>Move your mouse over the grid.</p>
<div id="paper" style="height: 500px; width: 800px; background-color: #444;"></div>
<p>
  Crossing an edge changes exactly one coordinate.
</p>
<p>
  The graphics are generated by <a href="http://raphaeljs.com">Raphaël</a>.
</p>
<ul>
  <li><span style="color: white; background: darkred;">darkred</span>, <span style="color: white; background: darkblue;">darkblue</span> and <span style="color: white; background: darkgreen;">darkgreen</span>: u, v and w-lane (the corresponding coordinate does not change on that lane)</li>
  <li><span style="color: white; background: red;">red</span>: highlighted triangle</li>
  <li><span style="color: white; background: blue;">blue</span>: neighbours of the highlighted triangle (triangles with at least one shared vertex)</li>
</ul>

<h2>Code</h2>
<p>
The conversion code is written in Coffeescript.
</p>
{% highlight coffeescript %}
# some constants
SR3 = Math.sqrt 3
PI30 = Math.PI / 6
PI60 = Math.PI / 3
SIN30 = Math.sin PI30
COS30 = Math.cos PI30
SIN60 = Math.sin PI60
COS60 = Math.cos PI60

# convert u/v/w coordinates to x/y coordinates based on the 
# side length s
to_xy = (s, u, v, w) ->
  r = SR3 * s / 6
  R = SR3 * s / 3
  h = SR3 * s / 2

  xu = 0
  yu = u * R

  xv = -v * COS30 * R
  yv = -v * SIN30 * R

  xw = w * COS30 * R
  yw = -w * SIN30 * R

  x = xu + xv + xw
  y = yu + yv + yw
  [x, y]

# convert x/y coordinates to u/v/w coordinates based on the 
# side length s
to_uvw = (s, x, y) ->
  return [0, 0, 0] if x is 0 and y is 0
  r = SR3 * s / 6
  R = SR3 * s / 3
  h = SR3 * s / 2

  u = (Math.floor (R + y) / h)
  if y > 0
    factor = -1
    offset = r
  else
    factor = 1
    offset = R
  v = factor * (Math.floor (Math.cos(PI60 - (Math.atan x/y)) * Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) + offset) / h)

  if y > 0
    factor = 1
    offset = R
  else
    factor = -1
    offset = r
  w = factor * (Math.floor (Math.cos(2 * PI60 - (Math.atan x/y)) * Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) + offset) / h)
  [u, v, w]

{% endhighlight %}

<script type="text/javascript" src="/javascripts/jquery-1.6.0.min.js"></script>
<script type="text/javascript" src="/javascripts/raphael.js"></script>
<script type="text/javascript" src="/javascripts/util.js"></script>
<script type="text/javascript" src="/javascripts/triangles.js"></script>

