---
title: Grids & Coordinate Systems
---

- content_for :assets do
  = javascript_include_tag 'blog/2011-06-18-grids-and-coordinate-systems/raphael.js'
  = javascript_include_tag 'blog/2011-06-18-grids-and-coordinate-systems/util.js'
  = javascript_include_tag 'blog/2011-06-18-grids-and-coordinate-systems/triangles.js'

%div
  %div
    %p
      For a software project (a multi-user browser game) I am currently
      evaluating different sorts of grid and coordinate system combinations. I
      came across a few great posts about that topic (
      %a{:href => "http://www-cs-students.stanford.edu/~amitp/game-programming/grids/"} Amit’s Thoughts on Grids
      and
      = succeed ")." do
        %a{:href => "http://simblob.blogspot.com/2007/06/distances-on-triangular-grid.html"} Blobs in Games: Distances on a triangular grid
      The latter provides a promising coordinate system based on
      = succeed "." do
        %a{:href => "http://cit.zesoi.fer.hr/downloadPaper.php?paper=435"} this paper
      To review the grid and coordinate system I put together an example.
    %h2 Example
    %p Move your mouse over the grid.
    #paper{:style => "height: 500px; background-color: #444;"}
    %p
      Crossing an edge changes exactly one coordinate.
    %p
      The graphics are generated by
      = succeed "." do
        %a{:href => "http://raphaeljs.com"} Raphaël
    %ul
      %li
        %span{:style => "color: white; background: darkred;"}> darkred
        ,
        %span{:style => "color: white; background: darkblue;"} darkblue
        and
        = succeed ":" do
          %span{:style => "color: white; background: darkgreen;"} darkgreen
        u, v and w-lane (the corresponding coordinate does not change on that lane)
      %li
        %span{:style => "color: white; background: red;"}> red
        \: highlighted triangle
      %li
        %span{:style => "color: white; background: blue;"}> blue
        \: neighbours of the highlighted triangle (triangles with at least one shared vertex)
    %h2 Code
    %p
      The conversion code is written in Coffeescript.
    - code("ruby") do
      \# some constants
      SR3 = Math.sqrt 3
      PI30 = Math.PI / 6
      PI60 = Math.PI / 3
      SIN30 = Math.sin PI30
      COS30 = Math.cos PI30
      SIN60 = Math.sin PI60
      COS60 = Math.cos PI60
      
      \# convert u/v/w coordinates to x/y coordinates based on the
      \# side length s
      to_xy = (s, u, v, w) ->
      r = SR3 * s / 6
      R = SR3 * s / 3
      h = SR3 * s / 2
      
      xu = 0
      yu = u * R
      
      xv = -v * COS30 * R
      yv = -v * SIN30 * R
      
      xw = w * COS30 * R
      yw = -w * SIN30 * R
      
      x = xu + xv + xw
      y = yu + yv + yw
      [x, y]
      
      \# convert x/y coordinates to u/v/w coordinates based on the
      \# side length s
      to_uvw = (s, x, y) ->
      return [0, 0, 0] if x is 0 and y is 0
      r = SR3 * s / 6
      R = SR3 * s / 3
      h = SR3 * s / 2
      
      u = (Math.floor (R + y) / h)
      if y > 0
      factor = -1
      offset = r
      else
      factor = 1
      offset = R
      v = factor * (Math.floor (Math.cos(PI60 - (Math.atan x/y)) * Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) + offset) / h)
      
      if y > 0
      factor = 1
      offset = R
      else
      factor = -1
      offset = r
      w = factor * (Math.floor (Math.cos(2 * PI60 - (Math.atan x/y)) * Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) + offset) / h)
      [u, v, w]
